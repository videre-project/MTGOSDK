<Project>

  <Target Name="CleanProject"
          BeforeTargets="Clean">
    <ItemGroup>
      <FoldersToClean Include="$(DistDir)" />
      <FoldersToClean Include="$(FeedOutputPath)"
                      Condition="'$(UseLocalFeed)' != 'true'" />
      <FoldersToClean Include="$(PackageOutputPath)"
                      Condition="'$(UseLocalFeed)' != 'true'" />
      <FoldersToClean Include="$(MSBuildProjectDirectory)\bin" />
      <FoldersToClean Include="$(MSBuildProjectDirectory)\logs" />
      <FoldersToClean Include="$(MSBuildProjectDirectory)\obj" />
      <FoldersToClean Include="$(SolutionDir)\docs\_build\_site" />
      <FoldersToClean Include="$(SolutionDir)\docs\_build\_xmldoc" />
      <FoldersToClean Include="$(MSBuildProjectDirectory)\html-coverage-report" />
      <FilesToClean Include="$(MSBuildProjectDirectory)\coverage.cobertura.xml" />
      <FilesToClean Include="$(MSBuildProjectDirectory)\coverage.json" />
    </ItemGroup>
    <RemoveDir Directories="@(FoldersToClean)" />
    <Delete Files="@(FilesToClean)" />
  </Target>

  <Target Name="PreBuildTimestamp"
          BeforeTargets="CoreCompile">
    <PropertyGroup>
      <BaseProjectOutputPath>$(MSBuildProjectDirectory)\$(IntermediateOutputPath)</BaseProjectOutputPath>
    </PropertyGroup>
    <ItemGroup>
      <ProjectOutputFiles Include="$(BaseProjectOutputPath)$(MSBuildProjectName).exe;
                                   $(BaseProjectOutputPath)$(MSBuildProjectName).dll" />
      <ProjectOutputFiles Remove="@(_ProjectOutputFiles)"
                          Condition="!Exists('%(Identity)')" />

      <ProjectUp2DateFile Include="$(BaseProjectOutputPath)$(MSBuildProjectName).csproj.Up2Date;
                                   $(BaseProjectOutputPath)$(MSBuildProjectName).Version.cs.new" />
      <ProjectUp2DateFile Remove="@(ProjectUp2DateFile)"
                          Condition="!Exists('%(Identity)')" />
    </ItemGroup>
    <PropertyGroup Condition="'$(IsBuildRunningInTest)' == 'false'">
      <OutputTimeStampBeforeBuild>%(ProjectOutputFiles.ModifiedTime)</OutputTimeStampBeforeBuild>
      <HasBuildRegenerated Condition="@(ProjectOutputFiles -> Count()) == 0">True</HasBuildRegenerated>
    </PropertyGroup>
  </Target>

  <UsingTask
    TaskName="CompareDates"
    TaskFactory="RoslynCodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <FirstDate  ParameterType="System.DateTime" Required="true" />
      <SecondDate ParameterType="System.DateTime" Required="true" />
      <Difference ParameterType="System.Double"   Required="true" />
      <Result     ParameterType="System.Boolean"  Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System"/>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
          double ToSeconds(DateTime date) => TimeSpan.FromTicks(date.Ticks).TotalSeconds;
          if (ToSeconds(FirstDate) <= ToSeconds(SecondDate) && Difference != 0.0)
            Result = false;
          else
            Result = (ToSeconds(FirstDate) - ToSeconds(SecondDate)) > Difference;
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask
    TaskName="ExtractPackages"
    TaskFactory="RoslynCodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Packages ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <DestinationRoot ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        if (Packages == null || Packages.Length == 0)
        {
          Log.LogMessage("No packages to extract.");
          return true;
        }

        Directory.CreateDirectory(DestinationRoot);
        foreach (var pkg in Packages)
        {
          var path = pkg.ItemSpec;
          if (!File.Exists(path))
          {
            Log.LogWarning($"Package not found: {path}");
            continue;
          }

          var id = Regex.Replace(Path.GetFileNameWithoutExtension(path), @"\.[0-9].*$", "");
          var dest = Path.Combine(DestinationRoot, id);
          Directory.CreateDirectory(dest);

          using var archive = ZipFile.OpenRead(path);
          foreach (var entry in archive.Entries)
          {
            if (string.IsNullOrEmpty(entry.FullName)) continue;
            var outPath = Path.Combine(dest, entry.FullName.Replace('/', Path.DirectorySeparatorChar));
            var outDir = Path.GetDirectoryName(outPath);
            if (!string.IsNullOrEmpty(outDir)) Directory.CreateDirectory(outDir);
            if (entry.FullName.EndsWith("/")) continue; // directory
            entry.ExtractToFile(outPath, overwrite: true);
          }

          Log.LogMessage(MessageImportance.High, $"Extracted {path} -> {dest}");
        }

        return true;
      ]]></Code>
    </Task>
  </UsingTask>

  <Target Name="PostBuildTimestamp"
          AfterTargets="CoreCompile">
    <!-- Compare timestamps of the output files before and after build -->
    <PropertyGroup>
      <OutputTimeStampAfterBuild>%(ProjectOutputFiles.ModifiedTime)</OutputTimeStampAfterBuild>
    </PropertyGroup>
    <CompareDates FirstDate="$(OutputTimeStampAfterBuild)"
                  SecondDate="$(OutputTimeStampBeforeBuild)"
                  Difference="1.00"
                  Condition="'$(OutputTimeStampBeforeBuild)' != ''">
      <Output TaskParameter="Result" PropertyName="HasTimestampUpdated" />
    </CompareDates>
    <PropertyGroup Condition="'$(HasTimestampUpdated)' == ''">
      <HasTimestampUpdated>True</HasTimestampUpdated>
    </PropertyGroup>

    <PropertyGroup>
      <OutputFilesModified>false</OutputFilesModified>
      <OutputFilesModified Condition="'$(HasTimestampUpdated)' == 'True'">true</OutputFilesModified>
    </PropertyGroup>
  </Target>

  <Target Name="SkipPostCompile"
          BeforeTargets="CopyFilesToOutputDirectory"
          AfterTargets="GenerateDependencyFile"
          Condition="'$(OutputFilesModified)' == 'false'">
    <ItemGroup>
      <ProjectFileWrites Include="@(FileWrites)"
                         Condition="'%(Extension)' == '.exe' Or
                                    '%(Extension)' == '.dll' Or
                                    '%(Extension)' == '.pdb'" />
    </ItemGroup>
    <PropertyGroup Condition="@(ProjectFileWrites -> Count()) > 0">
      <SkipCopyBuildProduct>true</SkipCopyBuildProduct>
    </PropertyGroup>
  </Target>

  <Target Name="OverrideIncrementalClean"
          BeforeTargets="IncrementalClean"
          AfterTargets="_CleanGetCurrentAndPriorFileWrites"
          Condition="'$(OutputFilesModified)' == 'false' And
                     '$(SkipCopyBuildProduct)' == 'true'">
    <ItemGroup>
      <ProjectFileWrites Include="$(OutputPath)$(MSBuildProjectName).exe;
                                  $(OutputPath)$(MSBuildProjectName).dll;
                                  $(OutputPath)$(MSBuildProjectName).pdb" />
      <_CleanPriorFileWrites Remove="@(ProjectFileWrites -> '$(MSBuildProjectDirectory)\%(RelativeDir)%(Filename)%(Extension)')"
                             Condition="Exists('%(FullPath)')" />
    </ItemGroup>
  </Target>

  <Target Name="EnsureReferencePath"
          AfterTargets="AfterBuild"
          Condition="'$(TargetRefPath)' != '' And !Exists('$(TargetRefPath)')">
    <PropertyGroup>
      <TargetRefExt>$([System.IO.Path]::GetExtension($(TargetRefPath)))</TargetRefExt>
      <TargetRefDir>$([System.IO.Path]::GetDirectoryName($(TargetRefPath)))</TargetRefDir>
    </PropertyGroup>
    <Copy SourceFiles="$(MSBuildProjectDirectory)\$(IntermediateOutputPath)$(MSBuildProjectName)$(TargetRefExt)"
          DestinationFolder="$(TargetRefDir)" />
  </Target>

  <!-- Override MTGOSDK package versions to use the local package feed -->
  <Target Name="UseLocalFeedPackageVersions"
          BeforeTargets="CollectPackageReferences"
          Condition="'$(UseLocalFeed)' == 'true'">
    <PropertyGroup>
      <PrereleaseSpecifier>*-preview.*</PrereleaseSpecifier>
    </PropertyGroup>
    <ItemGroup>
      <PackageReference Update="MTGOSDK"
                        VersionOverride="$(PrereleaseSpecifier)" />
      <PackageReference Update="MTGOSDK.MSBuild"
                        VersionOverride="$(PrereleaseSpecifier)" />
      <PackageReference Update="MTGOSDK.Win32"
                        VersionOverride="$(PrereleaseSpecifier)" />
    </ItemGroup>
  </Target>

  <Target Name="UpdateFeed"
          AfterTargets="Pack"
          Condition="'$(OS)' == 'Windows_NT'">
    <!-- Query all existing package versions in the feed -->
    <PropertyGroup>
      <FeedPackagePath>$(FeedOutputPath)\$(MSBuildProjectName.ToLower())</FeedPackagePath>
    </PropertyGroup>
    <ItemGroup>
      <_SDKPackagePaths Include="$(FeedPackagePath)\**\*.nupkg" />
      <_SDKPackagePaths>
        <VersionPath>$([System.IO.Path]::GetDirectoryName('%(Identity)').Replace('$(FeedOutputPath)\', ''))</VersionPath>
      </_SDKPackagePaths>
      <_SDKPackagePaths>
        <File>$([System.IO.Path]::Combine('%(VersionPath)', 'nupkg').Replace('\', '.'))</File>
        <Version>$([System.IO.Path]::GetFileName('%(VersionPath)'))</Version>
      </_SDKPackagePaths>
    </ItemGroup>

    <!-- Clean the local feed of old package versions -->
    <RemoveDir Directories="@(_SDKPackagePaths->'$(FeedOutputPath)\%(VersionPath)');
                            @(_SDKPackagePaths->'$(NuGetPackageRoot)\%(VersionPath)')"
               Condition="Exists($(FeedPackagePath))" />

    <!-- Add the built package to the local feed -->
    <PropertyGroup>
      <PackagePath>$(PackageOutputPath)\$(MSBuildProjectName).$(PackageVersion).nupkg</PackagePath>
    </PropertyGroup>
    <Exec Command="$(NuGetExePath) add $(PackagePath) ^
                    -Source $(FeedOutputPath) ^
                    -Verbosity quiet" />
  </Target>
  
  <!-- Custom target to build documentation using DocFX and DocProcessor -->
  <Target Name="docfx" Condition="'$(MSBuildProjectName)' == 'MTGOSDK'">
    <PropertyGroup>
      <DocProcessorDir>$(MSBuildThisFileDirectory)tools\DocFX\</DocProcessorDir>
      <DocFxDir>$(MSBuildThisFileDirectory)</DocFxDir>
    </PropertyGroup>

    <Message Text="=== DocFX Documentation Build Pipeline ===" Importance="High" />

    <!-- 0. Ensure package contents are available for DocFX -->
    <ItemGroup>
      <DocfxPackages Include="$(DocFxDir)publish\**\*.nupkg" />
    </ItemGroup>
    <Message Text="Preparing packages for DocFX from $(DocFxDir)publish" Importance="High" />
    <Error Condition="@(DocfxPackages->Count()) == 0"
           Text="No packages found under $(DocFxDir)publish. Ensure package artifacts are downloaded (or built) before running the docfx target." />
    <PropertyGroup>
      <DocfxExtractRoot>$(DocFxDir)dist</DocfxExtractRoot>
    </PropertyGroup>
    <MakeDir Directories="$(DocfxExtractRoot)" />
    <ExtractPackages Packages="@(DocfxPackages)"
                     DestinationRoot="$(DocfxExtractRoot)"
                     Condition="@(DocfxPackages->Count()) &gt; 0" />

    <!-- 1. Build DocProcessor Tool -->
    <Message Text="Building DocProcessor tool..." Importance="High" />
    <MSBuild Projects="$(DocProcessorDir)DocProcessor.csproj" Targets="Build" Properties="Configuration=Release" />

    <!-- 2. Get Version Info from extracted nuspec (preferred) or fall back to 0.0.0 -->
    <PropertyGroup>
      <!-- Use the MTGOSDK package nuspec extracted to dist -->
      <_DocfxPrimaryNuspec>$(DocfxExtractRoot)\MTGOSDK\MTGOSDK.nuspec</_DocfxPrimaryNuspec>
    </PropertyGroup>

    <Error Condition="!Exists('$(_DocfxPrimaryNuspec)')"
           Text="DocFX build expected nuspec at $(_DocfxPrimaryNuspec) (ensure packages were extracted from publish/)." />

    <XmlPeek Query="/*[local-name()='package']/*[local-name()='metadata']/*[local-name()='version']/text()"
             XmlInputPath="$(_DocfxPrimaryNuspec)"
             Condition="Exists('$(_DocfxPrimaryNuspec)')">
      <Output TaskParameter="Result" PropertyName="_NuspecVersion" />
    </XmlPeek>

    <XmlPeek Query="/*[local-name()='package']/*[local-name()='metadata']/*[local-name()='repository']/@commit"
             XmlInputPath="$(_DocfxPrimaryNuspec)"
             Condition="Exists('$(_DocfxPrimaryNuspec)')">
      <Output TaskParameter="Result" PropertyName="_NuspecCommit" />
    </XmlPeek>

    <PropertyGroup>
      <!-- Split version into main and optional suffix from nuspec version (e.g., 1.2.3-preview.5) -->
      <_VersionMain>$([System.Text.RegularExpressions.Regex]::Match('$(_NuspecVersion)', '^[^-]+').Value)</_VersionMain>
      <_VersionSuffix>$([System.Text.RegularExpressions.Regex]::Replace('$(_NuspecVersion)', '^[^-]+-?', ''))</_VersionSuffix>
      <_VersionMain Condition="'$(_VersionMain)' == ''">$(_NuspecVersion)</_VersionMain>
      <_VersionMain Condition="'$(_VersionMain)' == ''">0.0.0</_VersionMain>
      <_CommitHash Condition="'$(_NuspecCommit)' != ''">$(_NuspecCommit)</_CommitHash>
      <_CommitHash Condition="'$(_CommitHash)' == ''"></_CommitHash>
    </PropertyGroup>
    
    <!-- Extract short hash and URL -->
    <PropertyGroup>
      <_ShortHash>$(_CommitHash)</_ShortHash>
      <_ShortHash Condition="'$(_CommitHash)' != '' And $(_CommitHash.Length) &gt;= 7">$(_CommitHash.Substring(0, 7))</_ShortHash>
      <_CommitUrl Condition="'$(_ShortHash)' != ''">https://github.com/videre-project/MTGOSDK/commit/$(_ShortHash)</_CommitUrl>
    </PropertyGroup>

    <!-- Fallback to git hash if MinVer metadata is empty -->
    <Exec Command="git rev-parse --short HEAD" ConsoleToMSBuild="true" Condition="'$(_ShortHash)' == ''">
       <Output TaskParameter="ConsoleOutput" PropertyName="_ShortHash" />
    </Exec>
    <PropertyGroup>
       <_CommitUrl Condition="'$(_ShortHash)' != ''">https://github.com/videre-project/MTGOSDK/commit/$(_ShortHash)</_CommitUrl>
    </PropertyGroup>

    <Message Text="Building docs for version: $(_VersionMain) $(_VersionSuffix) + $(_ShortHash)" Importance="High" />

    <!-- 3. DocFX Metadata -->
    <Message Text="[1/6] Generating metadata..." Importance="High" />
    <Exec Command="dotnet docfx metadata $(DocFxDir)docfx.json" WorkingDirectory="$(DocFxDir)" />

    <!-- 4. Reorder Members -->
    <Message Text="[2/6] Reordering members by source order..." Importance="High" />
    <Exec Command="dotnet run --project $(DocProcessorDir)DocProcessor.csproj -c Release --no-build -- reorder -SourceRoot &quot;$(DocFxDir)MTGOSDK\src&quot; -YamlDirectory &quot;$(DocFxDir)docs\_build\_xmldoc\MTGOSDK&quot;" />

    <!-- 5. Remove Inherited Members -->
    <Message Text="[3/6] Removing inherited members..." Importance="High" />
    <Exec Command="dotnet run --project $(DocProcessorDir)DocProcessor.csproj -c Release --no-build -- remove-inherited -YamlDirectory &quot;$(DocFxDir)docs\_build\_xmldoc\MTGOSDK&quot;" />

    <!-- 6. Reclassify Events -->
    <Message Text="[4/6] Reclassifying event fields..." Importance="High" />
    <Exec Command="dotnet run --project $(DocProcessorDir)DocProcessor.csproj -c Release --no-build -- reclassify-events -YamlDirectory &quot;$(DocFxDir)docs\_build\_xmldoc\MTGOSDK&quot;" />

    <!-- 7. Organize TOC -->
    <Message Text="[5/6] Organizing TOC..." Importance="High" />
    <Exec Command="dotnet run --project $(DocProcessorDir)DocProcessor.csproj -c Release --no-build -- organize-toc -SourceRoot &quot;$(DocFxDir)MTGOSDK\src&quot; -TocPath &quot;$(DocFxDir)docs\_build\_xmldoc\MTGOSDK\toc.yml&quot;" />

    <!-- 8. DocFX Build -->
    <Message Text="[6/6] Building site..." Importance="High" />
    
    <!-- Execute DocFX build via external PowerShell script -->
    <Exec Command="powershell -ExecutionPolicy Bypass -NoProfile -File &quot;$(DocFxDir)docs\_build\docfx\build.ps1&quot; -DocFxDir &quot;.&quot; -VersionMain &quot;$(_VersionMain)&quot; -VersionSuffix &quot;$(_VersionSuffix)&quot; -ShortHash &quot;$(_ShortHash)&quot; -CommitUrl &quot;$(_CommitUrl)&quot;" 
          WorkingDirectory="$(DocFxDir)"
          ConsoleToMSBuild="true" />
    
    <Message Text="=== DocFX Build Complete ===" Importance="High" />
  </Target>

</Project>